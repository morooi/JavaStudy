# Java Web 笔记

[TOC]

## HTML

### 特殊字符

常用的特殊字符：

| 字符 | 实体标签 |
| :--: | :------: |
|  >   |  \&lt;   |
|  <   |  \&gt;   |
| 空格 | \&nbsp;  |

### 超链接

`<a></a> ` 标签是超链接

`href` 属性设置连接的地址

`target` 属性设置哪个目标进行跳转

​	`_self`：表示当前页面(默认值)

​	`_blank`：表示打开新页面来进行跳转

``` html
<a href="https://morooi.cn">morooi</a><br/>
<a href="https://morooi.cn" target="_self">morooi_self</a><br/>
<a href="https://morooi.cn" target="_blank">morooi_blank</a><br/>
```

### 列表标签

`<ul></ul>`：无序列表，`type` 属性可以修改列表项前面的符号

`<ol></ol>`：有序列表

`<li></li>`：列表项

例：

``` html
<!-- 无序列表 -->
<ul type="none">
  <li>赵四</li>
  <li>刘能</li>
  <li>小沈阳</li>
  <li>宋小宝</li>
</ul>

<!-- 有序列表 -->
<ol>
  <li>赵四</li>
  <li>刘能</li>
  <li>小沈阳</li>
  <li>宋小宝</li>
</ol>
```

### 图片标签

`<img />`：图片标签，用来显示图片

`src` 属性设置图片的路径

` width` 属性设置图片的宽度

`height` 属性设置图片的高度

`border` 属性设置图片边框大小

`alt` 属性设置当指定路径找不到图片时,用来代替显示的文本内容

``` html
<img src="1.jpg" width="200" height="260" border="1" alt="美女找不到"/>
<img src="../../2.jpg" width="200" height="260" />
<img src="../imgs/3.jpg" width="200" height="260" />
```

### 表格标签

`<table></table>`：表格标签

`border`：设置表格边框

`width`：设置表格宽度

`height`：设置表格高度

`align`：设置表格相对于页面的对齐方式

`cellspacing`：设置单元格间距



`<tr></tr>`：行标签

`<th></th>`：表头标签

`<td></td>`：单元格标签

`align`：设置单元格文本对齐方式

补充：`b`：加粗

``` html
<table align="center" border="1" width="300" height="300" cellspacing="0">
    <tr>
        <th>1.1</th>
        <th>1.2</th>
        <th>1.3</th>
    </tr>
    <tr>
        <td>2.1</td>
        <td>2.2</td>
        <td>2.3</td>
    </tr>
    <tr>
        <td>3.1</td>
        <td>3.2</td>
        <td>3.3</td>
    </tr>
</table>
```

跨行跨列表格

`colspan`：属性设置跨列

`rowspan`：属性设置跨行

``` html
<!-- 
新建一个五行，五列的表格，
第一行，第一列的单元格要跨两列，
第二行第一列的单元格跨两行，
第四行第四列的单元格跨两行两列。
-->

<table width="500" height="500" cellspacing="0" border="1">
  <tr>
    <td colspan="2">1.1</td>
    <td>1.3</td>
    <td>1.4</td>
    <td>1.5</td>
  </tr>
  <tr>
    <td rowspan="2">2.1</td>
    <td>2.2</td>
    <td>2.3</td>
    <td>2.4</td>
    <td>2.5</td>
  </tr>
  <tr>
    <td>3.2</td>
    <td>3.3</td>
    <td>3.4</td>
    <td>3.5</td>
  </tr>
  <tr>
    <td>4.1</td>
    <td>4.2</td>
    <td>4.3</td>
    <td colspan="2" rowspan="2">4.4</td>
  </tr>
  <tr>
    <td>5.1</td>
    <td>5.2</td>
    <td>5.3</td>
  </tr>
</table>
```

### iframe 框架标签

`<iframe></iframe>` 标签可以在页面上开辟一个小区域显示一个单独的页面

ifarme 和 a 标签组合使用的步骤:

1. 在 iframe 标签中使用 name 属性定义一个名称

2. 在 a 标签的 target 属性上设置 iframe 的 name 的属性值

``` html
<iframe src="3.标题标签.html" width="500" height="400" name="abc"></iframe>
<br/>
<ul>
  <li><a href="0-标签语法.html" target="abc">0-标签语法.html</a></li>
  <li><a href="1.font标签.html" target="abc">1.font标签.html</a></li>
  <li><a href="2.特殊字符.html" target="abc">2.特殊字符.html</a></li>
</ul>
```

### 表单标签（重点）

表单就是 html 页面中，用来收集用户信息的所有元素集合，然后把这些信息发送给服务器

`<form></form>`：表单标签

​	`action` 属性设置提交的服务器地址

​	`method` 属性设置提交的方式 GET(默认值)或 POST

`<input type="text">`：文件输入框，`value` 设置默认显示内容

`<input type="password">`：密码输入框，`value` 设置默认显示内容

`<input type="radio">`：单选框，`name` 属性可以对其进行分组，`checked="checked"`表示默认选中

`<input type="checkbox">`：复选框，`checked="checked"`表示默认选中

`<input type="reset">`：重置按钮，`value` 属性修改按钮上的文本

`<input type="submit">`：提交按钮， `value` 属性修改按钮上的文本

`<input type="button">`：按钮， `value` 属性修改按钮上的文本

`<input type="file">`：文件上传域

`<input type="hidden">`：隐藏域。当要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器）



`<select></select>` ：下拉列表框标签

`<option></option>` 标签：下拉列表框中的选项 `selected="selected"` 表示默认选中

`<textarea></textarea>`：多行文本输入框 （起始标签和结束标签中的内容是默认值）

​	`row `属性设置可以显示几行的高度

​	`cols` 属性设置每行可以显示几个字符宽度

``` html
<form action="localhost/check.jsp" method="post">
  <h1 align="center">用户注册</h1>
  <table align="center">
    <tr>
      <td>用户名称：</td>
      <td>
        <input type="text" name="useranme" value="默认值"/>
      </td>
    </tr>
    <tr>
      <td>用户密码：</td>
      <td><input type="password" name="password" value="abc"/></td>
    </tr>
    <tr>
      <td>确认密码：</td>
      <td><input type="password" value="abc"/></td>
    </tr>
    <tr>
      <td>性别：</td>
      <td>
        <input type="radio" name="sex" value="male"/>男
        <input type="radio" name="sex" value="female" checked="checked"/>女
      </td>
    </tr>
    <tr>
      <td>兴趣爱好：</td>
      <td>
        <input type="checkbox" name="hobby" value="java" checked="checked" />Java
        <input type="checkbox" name="hobby" value="js"/>JavaScript
        <input type="checkbox" name="hobby" value="cpp"/>C++
      </td>
    </tr>
    <tr>
      <td>国籍：</td>
      <td>
        <select name="country">
          <option>--请选择国籍--</option>
          <option value="CN" selected="selected">中国</option>
          <option value="USA">美国</option>
          <option value="JP">日本</option>
        </select>
      </td>
    </tr>
    <tr>
      <td>自我评价：</td>
      <td><textarea name="desc" rows="10" cols="20">我才是默认值</textarea></td>
    </tr>
    <tr>
      <td><input type="reset"/></td>
      <td align="center" ><input type="submit"/></td>
    </tr>
  </table>
</form>
```



**表单提交的时候，数据没有发送给服务器的三种情况：**

1. 表单项没有 `name` 属性值
2. 单选、复选（下拉列表中的 `option` 标签）都需要添加 `value` 属性，以便发送给服务器
3. 表单项不在提交的 `form` 标签中



GET 请求的特点：

1. 浏览器地址栏中的地址是：URL?请求参数。请求参数的格式是：name=value&name=value

2. 不安全，数据会暴露在地址栏中

3. 它有数据长度的限制（100个字符）

POST请求的特点：

1. 浏览器地址栏中只有 form 中 action 的目标地址值

2. 相对于 GET 请求要安全

3. 理论上没有数据长度的限制

### 其他标签

`<div></div>` 标签，默认独占一行

`<span></span>` 标签，它的长度是封装数据的长度

`<p></p>`：段落标签，默认会在段落的上方或下方各空出一行来（如果已有就不再空）

## CSS

### 标签名选择器

标签名选择器可以决定哪些标签被动的使用这个样式

格式：

标签名 {
​	属性: 值;
}

``` html
<style type="text/css">
  div{
    border: 1px solid yellow;
    color: blue;
    font-size: 30px;
  }
  span{
    border: 5px dashed blue;
    color: yellow;
    font-size: 20px;
  }
</style>

<body>
  <!-- 
  在所有 div 标签上修改字体颜色为蓝色，字体大小 30px。边框为 1px 黄色实线。
  并且修改所有 span 标签的字体颜色为黄色，字体大小20px。边框为 5px 蓝色虚线。
  -->
  <div>div标签1</div>
  <div>div标签2</div>
  <span>span标签1</span>
  <span>span标签2</span>
</body>
```

### id 选择器

id 选择器可以让我们通过 id 属性选择性的去使用这个样式

格式：

\#id 属性值 {
​	属性: 值;
}

``` html
<style type="text/css">
  #id001 {
    color: blue;
    font-size: 30px;
    border: 1px yellow solid;
  }
  #id002 {
    color: red;
    font-size: 20px;
    border: 5px blue dotted ;
  }

</style>

<body>		
  <!--
  分别定义两个 div 标签
  第一个 div 标签定义 id 为 id001，根据 id 属性定义 css 样式修改字体颜色为蓝色，字体大小 30px。边框为 1px 黄色实线。
  第二个 div 标签定义 id 为 id002，根据 id 属性定义 css 样式修改字体颜色为红色，字体大小 20px。边框为 5px 蓝色点线。
   -->
  <div id="id002">div标签1</div>
  <div id="id001">div标签2</div>
</body>
```

### class 选择器

又叫类型选择器，可以通过 class 属性有效的选择性地去使用样式

格式：

.class 属性值 {
​	属性: 值;
}

``` html
<style type="text/css">
  .class01{
    color: blue;
    font-size: 30px;
    border: 1px solid yellow;
  }
  .class02{
    color: grey;
    font-size: 26px;
    border: 1px solid red;
  }
</style>

<body>
  <!--
  修改 class 属性值为 class01 的 span 或 div 标签，字体颜色为蓝色，字体大小 30px。边框为 1px 黄色实线。
  修改 class 属性值为 class02 的 div 标签，字体颜色为灰色，字体大小 26px。边框为 1px 红色实线。
   -->
  <div class="class01">div标签class01</div>
  <div class="class02">div标签</div>
  <span class="class02">span标签class01</span>
  <span>span标签2</span>
</body>
```

### 组合选择器

组合选择器可以让多个选择器共用同一个 css 样式代码

格式：

选择器1, 选择器2, 选择器n {
​	属性: 值;
}

``` html
<style type="text/css">
  .class01,
  #id01 {
    color: blue;
    font-size: 20px;
    border:  yellow 1px solid;
  }
</style>

<body>
  <!-- 
  需求1：修改 class="class01" 的div 标签 和 id="id01" 所有的span标签，
  字体颜色为蓝色，字体大小20个像素。边框为1像素黄色实线。
   -->
   <div id="id01">div标签class01</div><br/>
   <span class="class01">span 标签</span><br/>
   <div>div标签</div> <br/>
   <div>div标签id01</div><br/>
</body>
```

### 常用样式

1. 字体颜色：color

2. 宽度，高度：width, height

3. 背景颜色：backgroud-color

4. 字体大小：font-size

5. 边框：border

6. div 居中：

   ``` css
   margin-left: auto;
   margin-right: auto;
   ```

7. 文本居中：text-align: center;

8. 超链接去下划线：text-decoration: none;

9. 表格细线：

   ``` css
   table {
     border: 1px solid red; /*设置边框*/
     border-collapse: collapse; /*将边框合并*/
   }
   td, th {
     border: 1px solid red; /*设置边框*/
   }
   ```

10. 列表去除修饰（编号等）

    ``` css
    ul{
      list-style: none;
    }
    ```

## JavaScript

JS 是弱类型语言

特点：

* 交互性（可以做的就是信息的动态交互）
* 安全性（不允许直接访问本地硬盘）
* 跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无关）

### JavaScript 和 html 代码的结合方式

方式一：在 head 或 body 标签中，使用  `<script><script/>` 标签来书写 JavaScript 代码

方式二：使用  `<script><script/>` 标签引入单独的 JavaScript 代码文件

``` html
<head>
  <script type="text/javascript">
    // alert是JavaScript语言提供的一个警告框函数。
    alert("Hello JavaScript!");
  </script>

  <script type="text/javascript" src="test.js"></script>
</head>

<body>
  <script type="text/javascript">
    // alert是JavaScript语言提供的一个警告框函数。
    alert("Hello JavaScript!");
  </script>
</body>
```

### 变量

#### JavaScript 的变量类型

* 数值类型：number
* 字符串类型：string
* 对象类型：object
* 布尔类型：boolean
* 函数类型：function

#### JavaScript 里特殊的值

* undefined：未定义，所有 JS 变量未赋与初始值的时候，默认值都是 undefined
* null：空值
* NAN：全称是 Not a number。非数字、非数值

#### JavaStript 中的定义变量格式：

  ``` javascript
// var 变量名;
// var 变量名 = 值;

var i;
// alert(i); // undefined
i = 12;
// typeof() 是 JavaScript 语言提供的一个函数，它可以取变量的数据类型返回
// alert(typeof(i)); // number

i = "abc";
// alert(typeof(i)); // String

var a = 12;
var b = "abc";
alert( a * b ); // NaN，非数字，非数值。
  ```

### 关系（比较）运算

等于：`==`				（简单的做字面值的比较）

全等于：`===`		 （除了做字面值的比较之外，还会比较两个变量的数据类型）

``` javascript
var a = "12"; // string
var b = 12;	// number

alert( a == b ); // true
alert( a === b ); // false
```

### 逻辑运算

> 在 JavaScript 语言中，所有的变量，都可以作为一个 boolean 类型的变量去使用
>
> *0, null, undefined, ""(空串)* 都认为是 false

且运算：`&&`

或运算：`||`

取反运算：`!`

``` javascript
var a = 0;
if (a) {
  alert("零为真");
} else {
  alert("零为假"); // <-- 结果
}

var b = null;
if (b) {
  alert("null为真");
} else {
  alert("null为假"); // <-- 结果
}

var c = undefined;
if (c) {
  alert("undefined 为真");
} else {
  alert("undefined 为假"); // <-- 结果
}

var d = "";
if (d) {
  alert("空串为真");
} else {
  alert("空串为假"); // <-- 结果
}

/*	
&& 且运算，有两种情况：
第一种：当表达式全为真的时候。返回最后一个表达式的值。
第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值
*/
var a = "abc";
var b = true;
var d = false;
var c = null;
alert(a && b); // true
alert(b && a); // true
alert(a && d); // false
alert(a && c); // null

/*
|| 或运算
第一种情况：当表达式全为假时，返回最后一个表达式的值
第二种情况：只要有一个表达式为真。就会返回第一个为真的表达式的值
*/
alert(d || c); // null
alert(c || d); // false
alert(a || c); // abc
alert(b || c); // true
```

### 数组（重点）

JavaScript 中的数组：

``` javascript
var 数组名 = []; // 空数组
var 数组名 = [1, 'abc', true] // 定义数组同时赋值元素

// JavaScript 语言中的数组，只要我们通过数组下标赋值，那么最大的下标值，就会自动的给数组做扩容操作。
var arr = []; // 定义一个空数组
alert(arr.length); // 0

arr[0] = 12;
alert(arr[0]); // 12
alert(arr.length); // 1

arr[2] = "abc";
alert(arr.length); // 3
alert(arr[1]); // undefined

// 数组的遍历
for (var i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
```

### 函数（重点）

#### 函数的两种定义方式

两种定义方式：

1. 使用 function 关键字定义函数

   function 函数名(形参) {
   ​	函数体
   }
   
   ``` javascript
   function fun() {
     alert("无参函数 fun()被调用了");
   }
   fun();
   
   function fun2(a, b) {
     alert("有参函数 fun2() 被调用了 a => " + a + ", b => "+b);
   }
   fun2(12, "abc");
   
   
   // 定义带有返回值的函数
   function sum(num1, num2) {
     var result = num1 + num2;
     return result;
   }
   alert(sum(100, 50));
   ```
   
2. 格式：

   var 函数名 = function (形参列表) {函数体}

   ``` javascript
   var fun = function () {
     alert("无参函数");
   }
   fun();
   
   var fun2 = function (a, b) {
     alert("有参函数 a = " + a + ", b = " + b);
   }
   fun2(1, 2);
   
   var fun3 = function (num1, num2) {
     return num1 + num2;
   }
   alert(fun3(100, 200));
   ```



**<span style="color: red">注意：</span>**JavaScript 中函数的重载会直接覆盖掉上一次的定义

``` javascript
// JS 不允许函数重载
function fun(a, b) {
  alert("有参函数fun(a, b)");
}

function fun() {
  alert("无参函数fun()");
}

fun(1, "ad"); // 无参函数fun()
```

#### 函数的 arguments 隐形参数（只在 function 函数内）

隐形参数就是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。

（像 Java 基础的可变长参数）

``` javascript
function fun(a) {
  alert(arguments.length); // 可看参数个数

  alert(arguments[0]);
  alert(arguments[1]);
  alert(arguments[2]);
  for (var i = 0; i < arguments.length; i++){
    alert(arguments[i]);
  }
  
  alert("a = " + a);
  alert("无参函数fun()");
}
fun(1, "ad", true);

// 要求编写一个函数，用于计算所有参数相加的和并返回
function sum(num1, num2) {
  var result = 0;
  for (var i = 0; i < arguments.length; i++) {
    if (typeof(arguments[i]) == "number") {
      result += arguments[i];
    }
  }
  return result;
}

alert(sum(1, 2, 3, 4, "abc", 5, 6, 7, 8, 9));
```

### 自定义对象

#### Object 形式的自定义对象

``` javascript
// 对象的定义
var 变量名 = new Object(); // 对象实例（空对象）
变量名.属性值 = 值; // 定义一个属性
变量名.函数名 = function() {} // 定义一个函数

var obj = new Object();
obj.name = "华仔";
obj.age = 18;
obj.fun = function () {
  alert("姓名：" + this.name + "，年龄：" + this.age);
}

// 对象的访问：
变量名.属性 / 函数名();

alert(obj.age);
obj.fun();
```

#### {} 花括号形式的自定义对象

``` javascript
// 对象的定义：
var 变量名 = {			// 空对象
  属性名: 值,			// 定义一个属性
  属性名: 值,			// 定义一个属性
  函数名: function() {}	// 定义一个函数
};

var obj = {
  name: "国哥",
  age: 18,
  fun: function () {
    alert("姓名：" + this.name + "，年龄：" + this.age);
  }
};

// 对象的访问：
变量名.属性 / 函数名();

alert(obj.name);
obj.fun();
```

### 事件

事件是电脑输入设备与页面进行交互的响应

#### 事件的注册

事件注册（事件绑定）就是告诉浏览器，当事件响应后要执行哪些操作代码

分为**静态注册**和**动态注册**

##### 静态注册事件

通过 HTML 标签的事件属性直接赋予事件响应后的代码

##### 动态注册事件

先通过 JS 代码得到标签的 DOM 对象，然后再通过 `DOM 对象.事件名 = function() {}` 这种形式赋予事件响应后的代码

基本步骤：

1. 获取标签对象
2. 标签对象.对象名 = function() {}

#### 常用的事件

 ##### onload 加载完成事件

页面加载完成后常用于做页面 JS 代码初始化操作

``` html
<script type="text/javascript">
  // onload 事件静态注册
  function onloadFun() {
    alert('静态注册 onload 事件，所有代码');
  }
</script>

<body onload="onloadFun()">
</body>
```

``` html
<script type="text/javascript">
  // onload 事件动态注册，是固定写法
  window.onload = function () {
    alert("动态注册的 onload 事件");
  }
</script>
```

#####  onclick 点击事件

常用于按钮的点击响应操作

``` html
<script type="text/javascript">
  function onclickFun() {
    alert("静态注册 onclick 事件");
  }
</script>

<body>
  <!--静态注册 onClick 事件-->
  <button onclick="onclickFun();">按钮</button>
</body>
```

``` html
<script type="text/javascript">
  // 动态注册 onclick 事件
  window.onload = function () {
    // 1. 获取标签对象
    /*
     * document 是 JavaScript 语言提供的一个对象（文档）
     * get           获取
     * Element       元素（就是标签）
     * By            通过.... / 由... / 经...
     * Id            id 属性
     *
     * getElementById 通过 id 属性获取标签对象
     **/
    var btnObj = document.getElementById("btn");
    // alert(btnObj);
    
    // 2. 标签对象.事件名 = function(){}
    btnObj.onclick = function () {
      alert("动态注册的 onclick 事件");
    }
  }
</script>

<body>
  <!--动态注册 onclick 事件-->
  <button id="btn">按钮</button>
</body>
```

##### onblur 失去焦点事件

常用于输入框失去焦点后验证其输入内容是否合法

``` html
<script type="text/javascript">
  // 静态注册失去焦点事件
  function onblurFun() {
    // console 是控制台对象，是由 JavaScript 语言提供，专门用来向浏览器的控制器打印输出，用于测试使用
    // log() 是打印的方法
    console.log("静态注册失去焦点事件");
  }
</script>

<body>
    用户名: <input type="text" onblur="onblurFun();"><br/>
    密码: <input id="password" type="text" ><br/>
</body>
```

``` html
<script type="text/javascript">
  // 动态注册 onblur 事件
  window.onload = function () {
    // 1. 获取标签对象
    var passwordObj = document.getElementById("password");
    // alert(passwordObj);
    // 2. 标签对象.事件名 = function(){};
    passwordObj.onblur = function () {
      console.log("动态注册失去焦点事件");
    }
  }
</script>
```

#####  onchange 内容发生改变事件

常用于下拉列表和输入框内容发生改变后操作

``` html
<script type="text/javascript">
  function onchangeFun() {
    alert("女神已经改变了");
  }
</script>

<body>
  请选择你心中的女神：
  <!--静态注册onchange事件-->
  <select onchange="onchangeFun();">
    <option>--女神--</option>
    <option>芳芳</option>
    <option>佳佳</option>
    <option>娘娘</option>
  </select>
</body>
```

``` html
<script>
  window.onload = function () {
    // 1. 获取标签对象
    var selObj = document.getElementById("sel");
    // alert( selObj );
    // 2. 标签对象.事件名 = function(){}
    selObj.onchange = function () {
      alert("男神已经改变了");
    }
  }
</script>

<body>
  请选择你心中的男神：
  <select id="sel">
    <option>--男神--</option>
    <option>国哥</option>
    <option>华仔</option>
    <option>富城</option>
  </select>
</body>
```

#####  onsubmit 表单提交事件

常用于表单提交前，验证所有表单项是否合法

``` html
<script type="text/javascript" >
  // 静态注册表单提交事件
  function onsubmitFun(){
    // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交
    alert("静态注册表单提交事件----发现不合法");
    return flase;
  }
</script>

<body>
  <!-- onsubmit="return false" 可以阻止表单提交 -->
  <form action="http://localhost" method="get" onsubmit="return onsubmitFun();">
    <input type="submit" value="静态注册"/>
  </form>
</body>
```

``` html
<script type="text/javascript" >
  window.onload = function () {
    // 1. 获取标签对象
    var formObj = document.getElementById("form");
    // 2. 标签对象.事件名 = function() {}
    formObj.onsubmit = function () {
      // 要验证所有表单项是否合法，如果，有一个不合法就阻止表单提交
      alert("动态注册表单提交事件----发现不合法");
      return false;
    }
  }
</script>

<body>
  <form action="http://localhost" id="form">
    <input type="submit" value="动态注册"/>
  </form>
</body>
```

### DOM

DOM 全程是 Document Object Model 文档对象模型

> 把文档中的标签、属性、文本，转换成对象来管理

#### document 对象

* document 管理了所有的 HTML 文档内容
* document 是一种树结构的文档，有层级关系
* document 把所有的标签都对象化
* 可以通过 document 访问所有的标签对象

#### document 对象的方法

document 对象的三个查询方法，如果有 id 属性，优先使用 **[getElementById](# getElementById(elementId))** 方法进行查询，如果没有 id 属性，则优先使用 **[getElementsByName](# getElementsByName(elementName))** 方法查询，如果既没有 id 属性也没有 name 属性就按标签名查询 **[getElementsByTagName](# getElementsByTagName(tagName))**

以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象

##### getElementById(elementId)

通过标签的 id 属性查找标签 dom 对象，elementId 是标签的 id 属性值

``` html
<script type="text/javascript" >
  /*
   * 当用户点击了校验按钮，要获取输出框中的内容。然后验证其是否合法
   * 验证的规则是：必须由字母、数字、下划线组成。并且长度是 5 到 12 位
   **/
  function onclickFun() {
    // 1. 当我们要操作一个标签的时候，一定要先获取这个标签对象。
    var usernameObj = document.getElementById("username");
    // [object HTMLInputElement] 它就是 dom 对象
    var usernameText = usernameObj.value;
    // 如何验证字符串，符合某个规则，需要使用正则表达式
    var patt = /^\w{5,12}$/;
    /*
     * test()方法用于测试某个字符串，是不是匹配我的规则，
     * 匹配就返回true。不匹配就返回false.
     **/

    var usernameSpanObj = document.getElementById("usernameSpan");
    // innerHTML 表示起始标签和结束标签中的内容
    // innerHTML 这个属性可读，可写
    usernameSpanObj.innerHTML = "国哥真可爱！";

    if (patt.test(usernameText)) {
      // alert("用户名合法！");
      usernameSpanObj.innerHTML = "用户名合法！";
      // usernameSpanObj.innerHTML = "<img src=\"right.png\" width=\"18\" height=\"18\">";
    } else {
      // alert("用户名不合法！");
      usernameSpanObj.innerHTML = "用户名不合法！";
      // usernameSpanObj.innerHTML = "<img src=\"wrong.png\" width=\"18\" height=\"18\">";
    }
  }
</script>

<body>
  用户名：<input type="text" id="username" value="wzg"/>
  <span id="usernameSpan" style="color:red;"></span><br/>
  <button onclick="onclickFun()">校验</button>
</body>
```

##### getElementsByName(elementName)

通过标签的 name 属性查找标签 dom 对象，elementName 是标签的 name 属性值，会返回多个值

``` html
<script type="text/javascript">
  // 全选
  function checkAll() {
    // 让所有复选框都选中
    // document.getElementsByName();根据指定的 name 属性查询返回多个标签对象集合
    // 这个集合的操作跟数组一样
    // 集合中每个元素都是 dom 对象
    // 这个集合中的元素顺序是他们在 html 页面中从上到下的顺序
    var hobbies = document.getElementsByName("hobby");
    // checked 表示复选框的选中状态。如果选中是true，不选中是false
    // checked 这个属性可读，可写
    for (var i = 0; i < hobbies.length; i++){
      hobbies[i].checked = true;
    }
  }
  
  //全不选
  function checkNo() {
    var hobbies = document.getElementsByName("hobby");
    // checked 表示复选框的选中状态。如果选中是true，不选中是false
    // checked 这个属性可读，可写
    for (var i = 0; i < hobbies.length; i++){
      hobbies[i].checked = false;
    }
  }
  // 反选
  function checkReverse() {
    var hobbies = document.getElementsByName("hobby");
    for (var i = 0; i < hobbies.length; i++) {
      hobbies[i].checked = !hobbies[i].checked;
      // if (hobbies[i].checked) {
      //     hobbies[i].checked = false;
      // }else {
      //     hobbies[i].checked = true;
      // }
    }
  }
</script>

<body>
    兴趣爱好：
    <input type="checkbox" name="hobby" value="cpp" checked="checked">C++
    <input type="checkbox" name="hobby" value="java">Java
    <input type="checkbox" name="hobby" value="js">JavaScript
    <br/>
    <button onclick="checkAll()">全选</button>
    <button onclick="checkNo()">全不选</button>
    <button onclick="checkReverse()">反选</button>
</body>
```

##### getElementsByTagName(tagName)

通过标签名查找标签 dom 对象，tagName 是标签名

``` html
<script type="text/javascript">
  window.onload = function(){
    // alert( document.getElementById("btn01") );
  }

  // 全选
  function checkAll() {
    alert( document.getElementById("btn01") );
    // document.getElementsByTagName("input");
    // 是按照指定标签名来进行查询并返回集合
    // 这个集合的操作跟数组一样
    // 集合中都是 dom 对象
    // 集合中元素顺序是他们在html页面中从上到下的顺序。
    var inputs = document.getElementsByTagName("input");
    for (var i = 0; i < inputs.length; i++){
      inputs[i].checked = true;
    }
  }
</script>

<body>
    兴趣爱好：
    <input type="checkbox" value="cpp" checked="checked">C++
    <input type="checkbox" value="java">Java
    <input type="checkbox" value="js">JavaScript
    <br/>
    <button id="btn01" onclick="checkAll()">全选</button>

</body>
```

##### createElement(tagName)

通过给定的标签名，创建一个标签对象，tagName 是要创建的标签名

``` html
<script type="text/javascript">
  window.onload = function () {
    // 现在需要我们使用 js 代码来创建 html 标签，并显示在页面上
    // 标签的内容就是：<div>国哥，我爱你</div>
    var divObj = document.createElement("div"); // 在内存中 <div></div>

    var textNodeObj = document.createTextNode("国哥，我爱你"); // 有一个文本节点对象 #国哥，我爱你

    divObj.appendChild(textNodeObj); // <div>国哥，我爱你</div>

    // divObj.innerHTML = "国哥，我爱你"; // <div>国哥，我爱你</div>，但还只是在内存中
    // 添加子元素
    document.body.appendChild(divObj);
  }
</script>
```



#### 节点的常用方法和属性

##### 方法

通过具体的元素节点调用 getElementsByTagName() 方法获取当前节点的指定标签名孩子节点

通过具体的元素节点调用 appendChild(oChildNode) 方法添加一个子节点

##### 属性

childNodes：获取当前节点的所有子节点

firstChild：获取当前节点的第一个子节点

lastChild：获取当前节点的最后一个子节点

parentNode：获取当前节点的父节点

nextSibling：获取当前节点的下一个节点

previousSibling：获取当前节点的上一个节点

className：获取、设置标签的 class 属性值

innerHTML：获取、设置起始标签和结束标签中的内容

innerText：获取、设置起始标签和结束标签中的文本

## jQuery

### jQuery 核心函数

`$` 是 jQuery 的核心函数，能完成 jQuery的很多功能。`$()` 就是调用这个函数

1. 传入参数为**函数**时：表示页面加载完成之后。相当于 `window.onload = function() {}`

   ``` javascript
   $(function() {
     alert("页面加载完成后自动调用")
   });
   ```

2. 传入参数为**HTML 字符串**时：会根据这个字符串创建元素节点对象

   ``` javascript
   $("    <div>" +
     "        <span>div-span1</span>" +
     "        <span>div-span2</span>" +
     "    </div>").appendTo("body");
   ```

3. 传入参数为**选择器字符串**时：

   ``` html
   <script type="text/javascript">
   // $("#id 属性值"); id 选择器，根据 id 查询标签对象
   // $("标签名"); 标签名选择器，根据指定的标签名查询标签对象
   // $(".class 属性值"); 类型选择器，可以根据 class 属性查询标签对象
   
   alert($("#btn").length) // id 选择器
   alert($("button").length); // 标签名选择器
   alert($(".buttonClass").length) // 类型选择器
   </script>
   
   <body>
     <button id="btn" class="buttonClass">按钮</button>
   </body>
   ```

4. 传入参数为**DOM对象**时：会把这个 DOM 对象转换为 jQuery 对象

### DOM 对象和 jQuery 对象互转

jQuery 对象的本质就是：DOM 对象的数组 + jQuery 提供的一系列功能函数

#### DOM -> jQuery

`$(DOM 对象)`，🥳

#### jQuery -> DOM

`jQuery 对象[下标]`，🥳

### jQuery 选择器（重点）

#### 基本选择器

* `#id`：根据 id 查找标签对象

* `element`：根据标签名查找标签对象

* `.class`：根据 class 查找标签对象

* `*`：表示任意的，所有的元素

* `selector1, selector2, selectorN`：组合多个选择器的结果并返回

  ``` html
  <div>div</div>
  <p class="myClass">p class="myClass"</p>
  <span>span</span>
  <p class="notMyClass">p class="notMyClass"</p>
  ```

  jQuery 代码：

  ``` javascript
  $("div, span, p.myClass")
  
  // 结果:
  // [ <div>div</div>, <p class="myClass">p class="myClass"</p>, <span>span</span>]
  ```

  其中 `p.myClass` 表示标签名是 `p` 并且 class 为 `myClass` 的对象

#### 层级选择器

* `ancestor descendan`t：后代选择器，在给定的祖先元素下匹配所有的后代元素
* `parent > child`：子元素选择器，在给定的父元素下匹配所有的子元素
* `prev + next`：相邻元素选择器，匹配所有紧接在 prev 元素后的 next 元素
* `prev ~ siblings`：之后的兄弟元素选择器，匹配 prev 元素之后所有的 siblings 元素

#### 过滤选择器

* <span style="color: red">**`:first`**</span>：获取第一个元素
* <span style="color: red">**`:last`**</span>：获取最后一个元素
* `:not(selector)`：去除所有与给定选择器匹配的元素
* `:even`：匹配所有索引值为偶数的元素，从 0 开始计数
* `:odd`：匹配所有索引值为奇数的元素，从 0 开始计数
* <span style="color: red">**`:eq(index)`**</span>：匹配一个给定索引值的元素
* `:gt(index)`：匹配所有大于给定索引值的元素
* `:lt(index)`：匹配所有小于给定索引值的元素
* `:header`：匹配如 h1, h2, h3 之类的标题元素
* `:animated`：匹配所有正在执行动画效果的元素
* `:focus`

#### 内容过滤选择器

* `:contains(text)`：匹配包含给定文本的元素
* `:empty`：匹配所有不包含子元素或者文本的空元素
* `:parent`：匹配包含子元素或者文本的元素
* `:has(selector)`：匹配含有选择器所匹配的元素的元素

#### 属性过滤选择器

* <span style="color: red">**`[attribute]`**</span>：匹配包含给定属性的元素
* <span style="color: red">**`[attribute=value]`**</span>：匹配给定的属性是某个特定值的元素
* `[attribute!=value]`：匹配所有不含有指定的属性，或者属性不等于特定值的元素
* `[attribute^=value]`：匹配给定的属性是以某些值开始的元素
* `[attribute$=value]`：匹配给定的属性是以某些值结尾的元素
* `[attribute*=value]`：匹配给定的属性是以包含某些值的元素
* `[attrSel1][attrSel2][attrSelN]`：复合属性选择器，需要同时满足多个条件时使用

### jQuery 元素筛选

* `eq()`：获取给定索引的元素（功能和 `:eq()` 一样）
* `first()`：获取第一个元素（功能和 `:first` 一样）
* `last()`：获取最后一个元素（功能和 `:last` 一样）
* `filter(exp)`：留下匹配的元素
* `is()`：判断是否匹配给定的选择器，只要有一个匹配就返回 true
* `has(exp)`：返回包含有匹配选择器的元素的元素（功能和 `:has` 一样）
* `not(exp)`：删除匹配选择器的元素（功能和 `:not` 一样）
* `children(exp)`：返回匹配给定选择器的子元素（功能和 `parent > child` 一样）
* `find(exp)`：返回匹配给定选择器的后代元素（功能和 `ancestor descendant` 一样）
* `next()`：返回当前元素的下一个兄弟元素（功能和 `prev + next` 一样）
* `nextAll()`：返回当前元素后面所有的兄弟元素（功能和 `prev ~ siblings` 一样）
* `nextUntil()`：返回当前元素到指定匹配的元素为止的后面元素
* `parent()`：返回父元素
* `prev(exp)`：返回当前元素的上一个兄弟元素
* `prevAll()`：返回当前元素前面所有的兄弟元素
* `prevUnit(exp)`：返回当前元素到指定匹配的元素为止的前面元素
* `siblings(exp)`：返回所有兄弟元素
* `add()`：把 add 匹配的选择器的元素添加到当前 jQuery 对象中

## Servlet

### 什么是 Servlet

1. Servlet 是 JavaEE 规范之一。
2. Servlet 是 JavaWeb 三大组件之一。分别是：Servlet 程序、Filter 过滤器、Listener 监听器
3. Servlet 是运行在服务器上的一个 Java 小程序，可以接收客户端发送过来的请求，并响应数据给客户端

### 手动实现 Servlet 程序

1. 编写一个类去实现 Servlet 接口
2. 实现 service 方法，处理请求，并响应数据
3. 到 web.xml 中去配置 Servlet 程序的访问地址

### Servlet 的生命周期

程序：cn.morooi.servlet.Demo01HelloMyServlet

1. 执行 Servlet 构造器方法
2. 执行 init 初始化方法
3. 执行 service 方法
4. 执行 destroy 销毁方法

>第一、二步，在第一次访问的时候创建 Servlet 程序会调用
>
>第三步，每次访问都会调用
>
>第四步，在 Web 工程停止的时候调用

### 通过继承 HttpServlet 实现 Servlet 程序

程序：cn.morooi.servlet.Demo02HelloMyServlet

一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序

1. 编写一个类去继承 HttpServlet 类
2. 根据业务需要重写 doGet 或 doPost 方法
3. 到 web.xml 中的配置 Servlet 程序的访问地址

### Servlet 类的继承体系

![](https://s1.ax1x.com/2020/03/18/8B5Vx0.jpg)

### ServletConfig 类

Servlet 程序的配置信息类

> Servlet 程序和 ServletConfig 对象都是有 Tomcat 负责创建，我们负责使用
>
> Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对象

作用：

* 获取 Servlet 程序的别名 servlet-name 的值
* 获取初始化参数 init-param
* 获取 ServletContext 对象

**注意**：重写 init 方法里面一定要调用父类的 init(ServletConfig) 操作

### ServletContext 类

* ServletContext 是一个接口，他表示 Servlet 上下文对象
* 一个 web 工程只有一个 ServletContext 对象实例
* ServletContext 对象是一个域对象
* ServletContext 对象是在 web 工程部署启动的时候创建，在 web 工程停止的时候销毁

> 域对象：可以像 Map 一样存取数据的对象
>
> 这里的域指的是存取数据的操作范围，整个 web 工程
>
> |        |     存数据     |     取数据     |     删除数据      |
> | ------ | :------------: | :------------: | :---------------: |
> | Map    |     put()      |     get()      |     remove()      |
> | 域对象 | setAttribute() | getAttribute() | removeAttribute() |

#### ServletContext 类的四个作用

代码：cn.morooi.servlet.Demo03ServletContext

1. 获取 web.xml 中配置的上下文参数 context-param
2. 获取当前的工程路径，格式：`/工程路径`
3. 获取工程部署后在服务器硬盘上的绝对路径
4. 像 Map 一样存取数据

### 请求的 HTTP 协议格式

客户端给服务器发送数据叫请求；

服务器给客户端回传数据叫响应。

请求分为 **GET 请求**和 **POST 请求**

#### GET 请求

1. 请求行

   1. 请求的方式	(GET)
   2. 请求的资源路径[+?+请求参数]
   3. 请求的协议的版本号（HTTP/1.1）

2. 请求头

   key: value，不同键值对表示不同的含义

![](https://i.loli.net/2020/03/18/4Er7AFZIcKBu91g.jpg)

#### POST 请求

1. 请求行

   1. 请求的方式	(POST)
   2. 请求的资源路径[+?+请求参数]
   3. 请求的协议的版本号（HTTP/1.1）

2. 请求头

   1. key: value，不同键值对表示不同的含义

3. 请求体

   就是发送给服务器的数据

![](https://i.loli.net/2020/03/18/qkumzFhI4VAjDPM.jpg)

#### 常用请求头的说明

Accept：客户端可以接收的数据类型

Accpet-Languege：客户端可以接收的语言类型

User-Agent：客户端浏览器的信息

Host：请求时的服务器 ip 和端口号

#### 哪些是 GET请求，哪些是 POST

GET 请求有哪些：

1. form 标签 method=get
2. a 标签
3. link 标签引入 css
4. Script 标签引入 js 文件
5. img 标签引入图片
6. iframe 引入 html 页面
7. 在浏览器地址栏中输入地址后敲回车

POST 请求有哪些：

* form 标签 method=post

### 响应的 HTTP 协议格式

1. 响应行

   1. 响应的协议和版本号
   2. 响应状态码
   3. 响应状态描述符

2. 响应头

   key: value，不同的响应头，有其不同含义

3. 响应体 --> 回传给客户端的数据

![](https://i.loli.net/2020/03/19/NRzb7ySjQqBgWTi.jpg)

### 常见的响应码

* 200：请求成功
* 302：请求重定向
* 404：请求服务器已经收到了，但是你要的数据不存在(请求地址错误)
* 500：服务器已经收到请求，但是服务器内部错误 (代码错误)

### MIME 类型说明

MIME 是 HTTP 协议中数据类型。MIME 的英文全称是 "Multipurpose Internet Mail Extensions" 多功能 Internet 邮件扩充服务。

MIME 类型的格式是 “大类型/小类型”，并与某一种文件的扩展名相对应。

常见的 MIME类型：

| 文件               | 扩展名       | MIME类型                |
| ------------------ | ------------ | ----------------------- |
| 超文本标记语言文本 | .html , .htm | text/html               |
| 普通文本           | .txt         | text/plain              |
| RTF 文本           | .rtf         | application/rtf         |
| GIF 图形           | .gif         | image/gif               |
| JPEG 图形          | .jpeg, .jpg  | image/jpeg              |
| au 声音文件        | .au          | audio/basic             |
| MIDI 音乐文件      | .mid, .midi  | audio/midi,audio/x-midi |
| RealAudio 音乐文件 | .ra, .ram    | audio/x-pn-realaudio    |
| MPEG 文件          | .mpg, .mpge  | video/mpeg              |
| AVI 文件           | .avi         | video/x-msvideo         |
| GZIP 文件          | .gz          | application/x-gzip      |
| TAR文件            | .tar         | application/x-tar       |

### HTTPServletRequest 类

#### 作用

每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法 (doGet 和 doPost) 中给我们使用。

我们可以通过 HttpServletRequest 对象，获取到所有请求的信息。

#### 常用方法

* `getRequestURI()`：获取请求的资源路径
* `getRequestURL()`：获取请求的统一资源定位符（绝对路径）
* `getRemoteHost()`：获取客户端的 ip 地址
* `getHeader()`：获取请求头
* `getParameter()`：获取请求的参数
* `getParameterValues()`：获取请求的参数(多个值的时候使用)
* `getMethod`：获取请求的方式 GET 或 POST
* `setAttribute(key, value)`：设置域数据
* `getAttribute(key)`：获取域数据
* `getRequestDispatcher()`：获取请求转发对象
* `setCharacterEncoding(编码格式)`：设置 post 方式的请求编码

``` java
// 程序：cn.morooi.servlet.Demo04HttpServletRequest
public class Demo04HttpServletRequest extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // getRequestURI()：获取请求的资源路径
        String requestURI = request.getRequestURI();
        System.out.println("requestURI = " + requestURI);
        // getRequestURL()：获取请求的统一资源定位符（绝对路径）
        StringBuffer requestURL = request.getRequestURL();
        System.out.println("requestURL = " + requestURL);
        // getRemoteHost()：获取客户端的 ip 地址
        String remoteHost = request.getRemoteHost();
        System.out.println("remoteHost = " + remoteHost);
        // getHeader()：获取请求头
        String header = request.getHeader("User-Agent");
        System.out.println("header = " + header);
        // getMethod：获取请求的方式 GET 或 POST
        String method = request.getMethod();
        System.out.println("method = " + method);
    }
}
```

#### 获取请求参数

``` java
// 程序：cn.morooi.servlet.Demo04HttpServletRequest
// 表单：form1.html
public class Demo04HttpServletRequest extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // post 请求要设置字符集, 要在获取请求参数之前才有效
        request.setCharacterEncoding("utf-8");
        // getParameter()：获取请求的参数
        String username = request.getParameter("username");
        System.out.println(username);
        String password = request.getParameter("password");
        System.out.println(password);
        // getParameterValues()：获取请求的参数(多个值的时候使用)
        String[] hobbies = request.getParameterValues("hobby");
        System.out.println(Arrays.toString(hobbies));
    }
```

#### 请求的转发

服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。

``` java
// 程序：cn.morooi.servlet.Demo04HttpServletRequest
//      cn.morooi.servlet.Demo05HttpServletRequest
// 表单：form1.html

public class Demo04HttpServletRequest extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // post 请求要设置字符集, 要在获取请求参数之前才有效
        request.setCharacterEncoding("utf-8");

        // getParameter()：获取请求的参数
        String username = request.getParameter("username");
        System.out.println(username);
        // 请求转发
        System.out.println("转发前: " + username);
        // setAttribute(key, value)：设置域数据
        request.setAttribute("key", "柜台1的章");
        // getRequestDispatcher()：获取请求转发对象
        request.getRequestDispatcher("/httpServletRequest2").forward(request, response);
    }
}

public class Demo05HttpServletRequest extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String username = request.getParameter("username");
        System.out.println("转发后: " + username);

        // getAttribute(key)：获取域数据
        Object key = request.getAttribute("key");
        System.out.println("章: " + key);

        System.out.println("处理自己的业务....");
    }
}
```

![](https://i.loli.net/2020/03/19/EZMJzsp76LQk9VB.jpg)

#### base 标签的作用

`<base href="..."/>` 标签设置页面相对路径工作时参照的地址

![](https://i.loli.net/2020/03/19/qnECsz21l6jtGSv.jpg)

### HTTPServletResponse 类

HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。

> HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息。
>
> 如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置

#### 两个输出流

* 字节流 `getOutputStream();`	常用于下载（传递二进制数据）
* 字符流 `getWriter();`  常用于回传字符串（常用）

两个流同时只能使用一个，使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。

#### 往客户端回传数据

``` java
// 程序：cn.morooi.servlet.Demo06HttpServletResponse

public class Demo06HttpServletResponse extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置服务器字符集为 UTF-8
        response.setCharacterEncoding("UFT-8");
        // 通过设置响应头设置浏览器字符集
        response.setHeader("Content-Type", "text/html; charset=UTF-8");

      	// 推荐使用以下方法
        // setContentType() 同时设置服务器和客户端都使用 UTF-8, 而且设置了响应头
        // 此方法一定要在获取流对象之前调用才有效
        response.setContentType("text/html; charset=UTF-8");

        // 发送数据
        PrintWriter writer = response.getWriter();
        writer.write("返回一个字符串");
    }
}
```

#### 请求重定向

指客户端给服务器发请求，然后服务器告诉客户端说，我给你一些地址，你去新地址访问。

![](https://i.loli.net/2020/03/19/ha3Y97WwDexndmM.jpg)

``` java
// 程序：cn.morooi.servlet.Demo07Redirect

public class Demo07Redirect extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("重定向前....");
        // 设置响应状态码, 302 重定向
        response.setStatus(302);
        response.setHeader("Location", "form1.html");
        
        // 推荐使用以下方法重定向
        response.sendRedirect("form1.html");
    }
}
```

## JavaEE 的三层架构

![](https://i.loli.net/2020/03/19/ujagHD1QM4Xqf5i.jpg)

分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级

## JSP

JSP 的全称是 Java Server Pages，Java 的服务器页面

JSP 的主要作用是代替 Servlet 程序回传 html 页面的数据

### JSP 的本质

**JSP 页面本质上是一个 Servlet 程序**

当我们第一次访问 jsp 页面的时候，Tomcat 服务器会帮我们把 jsp 页面翻译成为一个 java 源文件，并且对它进行编译成 为.class 字节码程序。

### JSP 九大内置对象

* request：请求对象
* response：响应对象
* pageContext：jsp 的上下文对象
* session：会话对象
* application：ServletContext 对象
* config：ServletConfig 对象
* out：jsp 输出流对象
* page：指向当前 jsp 的对象
* Exception：异常对象

### JSP 四大域对象

作用范围从小到大，对象的范围越大，造成的性能损耗越大（尽量使用最小的范围）

|           对象           |                 范围                 |
| :----------------------: | :----------------------------------: |
| pageContext JSP 页面容器 |      当前页面有效（跳转后无效）      |
|     request 请求对象     |    同一次请求有效（重定向后无效）    |
|     session 会话对象     | 同一次会话有效（无论怎么跳转都有效） |
|   application 全局对象   |  全局有效（整个项目运行期间都有效）  |

共有的方法：

``` java
Object getAttribute(String name) // 根据属性名或属性值获取
void setAttribute(String name, Object obj) // 设置属性值（新增、修改）
void removeAttribute(String name) // 根据属性名，删除对象
```

### out 输出和 response.getWriter 输出的区别

response 中表示响应，我们经常用于设置返回给客户端的内容 (输出) 

out 也是给用户做输出使用的

![](https://i.loli.net/2020/03/19/DejwGK6sXbkJO1U.jpg)

由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下，我们在 jsp 页面中**统一使用 out 来进行输出**，避免打乱页面输出内容的顺序。

`out.write()` 输出字符串没有问题

`out.print()` 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出）

<span style="color: red">深入源码，浅出结论:在 jsp 页面中，可以统一使用 out.print()来进行输出</span>

## Listen 监听器

是 JavaWeb 的三大组件之一

> JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。

Listener 它是 JavaEE 的规范，就是接口 

监听器的作用是，监听某种事物的变化，然后通过回调函数，反馈给客户（程序）去做一些相应的处理

#### ServletContextListener 监听器

它可以监听 ServletContext 对象的创建和销毁

ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁，监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈。

#### 使用 ServletContextListener 监听器监听 ServletContext 对象

使用步骤如下:

1. 编写一个类去实现 ServletContextListener
2. 实现其两个回调方法
3. 到 web.xml 中去配置监听器

## Cookie 和 Session

### Cookie

Cookie（客户端，不是内置对象）：Cookie 是由服务端生成的，再发送给客户端保存，相当于本地缓存的作用 -> 提高访问服务端的效率，但是安全性较差。

Cookie 不是内置对象，要使用必须 new

Cookie: key=value

``` java
import javax.servlet.http.Cookie

public Cookie(String name, String value)
String getName() // 获取 name
String getValue() // 获取 value
void setMaxAge(int expiry) // 设置最大有效期（秒）
```

服务端准备 Cookie ：`response.addCookie(Cookie cookie)`	（response 对象）

页面跳转（转发、重定向）

客户端获取 Cookie：requese.getCookies()	（request 对象）

**客户端不能直接获取某一个单独对象，只能一次性将全部的 cookie 拿到**



### session

session 会话（开始到结束）

> 浏览网站：开始-关闭
>
> 购物：浏览、付款、退出
>
> 电子邮件：浏览、写邮件、退出

在 Cookies 中，除了自己设置的 Cookie 对象外，还有一个名字为 JSESSIONID 的 Cookie（在第一次请求时服务端自动产生）

#### session 机制

1. 客户端第一次请求服务端时（JSESSIONID != sessionID），服务端会产生一个 seesion 对象（用于保存该客户的信息），并且每个 session 对象都会有一个唯一的 sessionID（用于区分其他 session）。
2. 服务端会产生一个 Cookie，并且该 Cookie 的 name=JSESSIONID, value=sessionID
3. 服务端会在响应客户端的同时将该 Cookie 发送给客户端，至此客户端就有了一个名为 JSESSIONID 的 Cookie
4. 因此客户端的 Cookie 就可以和服务端的 session 对应（JSESSIONID = sessionID）

* 客户端第二次或第 N 次请求服务端时，服务端会先根据客户端 Cookie 中的 JSESSIONID 去服务端的 session 中匹配 sessionID，如果匹配成功，说明不是第一次访问

注意：

* session 存储在服务端

* session 是在同一个用户（客户）请求时共享
* 实现机制：第一次客户请求时产生一个 sessionID 并复制给 Cookie 的 JSESSIONID 然后发送给客户端

#### session 方法

```java
String getId() // 获取 sessionID
boolean isNew() // 判断是否是新用户（第一次访问）
void invalidate() // 使 session 失效（退出登录、注销）
  
void setAttribute()
Object getAttribute()
  
void setMaxInactiveInterval(秒) // 设置最大有效非活动时间
int getMaxInactiveInterval()
```

示例：/session

#### session 和 Cookie 的区别

|   区别点   | session |  Cookie  |
| :--------: | :-----: | :------: |
| 保存的位置 | 服务端  |  客户端  |
|   安全性   | 较安全  | 较不安全 |
| 保存的内容 | Object  |  String  |

![](https://i.loli.net/2020/03/20/MsQDT96U3tp2Nul.jpg)

## Filter 过滤器

* 它是 JavaWeb 的三大组件之一。三大组件分别是: Servlet 程序、Listener 监听器、Filter 过滤器
* 它是 JavaEE 的规范，也就是接口
* 作用是：拦截请求，过滤响应

> 拦截请求常见的应用场景有: 
>
> 1. 权限检查
> 2. 日记操作
> 3. 事务管理
> 4. ...

例：在 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必须是用户登录之后才允许访问。

![](https://i.loli.net/2020/03/20/4lQ63Tt5caXqwKe.jpg)

使用步骤:

1. 编写一个类去实现 Filter 接口
2. 实现过滤方法 `doFilter()`
3. 到 web.xml 中去配置 Filter 的拦截路径

### Filter 过滤器的生命周期

1. 构造器方法

2. init 初始化方法

   第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）

3. doFilter 过滤方法
   第 3 步，每次拦截到请求，就会执行

4. destroy 销毁
    第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）

### FilterConfig 类

它是 Filter 过滤器的配置文件类，Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。

FilterConfig 类的作用是获取 filter 过滤器的配置内容

1. 获取 Filter 的名称 filter-name 的内容
2. 获取在 Filter 中配置的 init-param 初始化参数
3. 获取 ServletContext 对象

### **FilterChain** 过滤器链

![](https://i.loli.net/2020/03/20/bGWzv3xku7M4TYP.jpg)

## JSON

JSON (JavaScript Object Notation) 是一种**轻量级的数据交换格式**，易于人阅读和编写，同时也易于机器解析和生成。

JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等），这样就使得 JSON 成为理想的数据交换格式。

轻量级指的是跟 xml 做比较，数据交换指的是客户端和服务器之间业务数据的传递格式。

### JSON 在 JavaScript 中的使用

#### 定义

JSON 是由键值对组成，并且由花括号（大括号）包围，每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。

``` javascript
var jsonObj = {
  "key1":12,
  "key2":abc,
  "key3":true,
  "key4":[11,"arr",false],
  "key5":{
    "key5_1":511,
    "key5_2":"key5_2_value"
  },
  "key6":[{
    "key6_1_1":6611,
    "key6_1_2":"key6_1_2_value"
  },{
    "key6_2_1":6621,
    "key6_2_2":"key6_2_2_value"
  }]
}
```

#### 访问

json 本身是一个对象，json 中的 key 可以理解为是对象中的一个属性。

json 中的 key 访问就跟访问对象的属性一样: `json 对象.key`

``` javascript
alert(jsonObj.key1) // 12
alert(jsonObj.ket2) // abc

/// json 中数组的遍历
for(var i = 0; i < jsonObj.key4.length; i++) {
  alert(jsonObj.key4[i]);
}

alert(jsonObj.key5.key5_1) // 511
```

#### 常用方法

json 的存在有两种形式。

一种是：对象的形式存在 --> json 对象

一种是：字符串的形式存在 --> json 字符串。

一般要操作 json 中的数据的时候，需要 json 对象的格式，通常在客户端和服务器之间进行数据交换的时候，使用 json 字符串

`JSON.stringify()`：把 json 对象转换成为 json 字符串

`JSON.parse()`：把 json 字符串转换成为 json 对象

``` javascript
// 把 json 对象转换成为 json 字符串
// 特别像 Java 中对象的 toString
var jsonObjString = JSON.stringify(jsonObj);
alert(jsonObjString);

// 把 json 字符串。转换成为 json 对象
var jsonObj2 = JSON.parse(jsonObjString);
alert(jsonObj2.key1);// 12
alert(jsonObj2.key2);// abc
```

### JSON 在 Java 中的使用

#### JavaBean 和 JSON 的互转

jar 包使用 gson

``` java
@Test
public void test1(){
  Person person = new Person(1, "国哥好帅!");
  // 创建 Gson 对象实例
  Gson gson = new Gson();
  // toJson 方法可以把 java 对象转换成为 json 字符串
  String personJsonString = gson.toJson(person);
  System.out.println(personJsonString);
  // fromJson 把 json 字符串转换回 Java 对象
  // 第一个参数是 json 字符串
  // 第二个参数是转换回去的 Java 对象类型
  Person person1 = gson.fromJson(personJsonString, Person.class);
  System.out.println(person1);
}
```

#### List 和 JSON 的互转

``` java
public class PersonListType() extends TypeToken<ArrayList<Person>> {}

@Test
public void test2() {
  List<Person> personList = new ArrayList<>();
  personList.add(new Person(1, "国哥"));
  personList.add(new Person(2, "康师傅"));
  
  Gson gson = new Gson();
  // 把 List 转换为 json 字符串
  String personListJsonString = gson.toJson(personList);
  System.out.println(personListJsonString);
  
  List<Person> list = gson.fromJson(personListJsonString, new PersonListType().getType());
  System.out.println(list);
  Person person = list.get(0);
  System.out.println(person);
}
```

#### map 和 JSON 的互转

``` java
@Test
public void test3(){
  Map<Integer,Person> personMap = new HashMap<>();
  personMap.put(1, new Person(1, "国哥好帅"));
  personMap.put(2, new Person(2, "康师傅也好帅"));
  
  Gson gson = new Gson();
  // 把 map 集合转换成为 json 字符串
  String personMapJsonString = gson.toJson(personMap);
  System.out.println(personMapJsonString);
  
  Map<Integer,Person> personMap2 = gson.fromJson(personMapJsonString, new TypeToken<HashMap<Integer,Person>>(){}.getType());
  System.out.println(personMap2);
  
  Person p = personMap2.get(1);
  System.out.println(p);
}
```

## AJAX

AJAX 即 Asynchronous Javascript And XML (异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。

ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术。

Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容